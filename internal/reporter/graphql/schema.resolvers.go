package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
	"time"

	authDomain "github.com/guidewire-oss/fern-platform/internal/domains/auth/domain"
	"github.com/guidewire-oss/fern-platform/internal/domains/integrations"
	projectsDomain "github.com/guidewire-oss/fern-platform/internal/domains/projects/domain"
	"github.com/guidewire-oss/fern-platform/internal/reporter/graphql/generated"
	"github.com/guidewire-oss/fern-platform/internal/reporter/graphql/model"
	"github.com/guidewire-oss/fern-platform/pkg/database"
	"gorm.io/gorm"
)

// CreateTestRun is the resolver for the createTestRun field.
func (r *mutationResolver) CreateTestRun(ctx context.Context, input model.CreateTestRunInput) (*model.TestRun, error) {
	return nil, fmt.Errorf("CreateTestRun not yet implemented")
}

// UpdateTestRunStatus is the resolver for the updateTestRunStatus field.
func (r *mutationResolver) UpdateTestRunStatus(ctx context.Context, runID string, status string, endTime *time.Time) (*model.TestRun, error) {
	return nil, fmt.Errorf("UpdateTestRunStatus not yet implemented")
}

// DeleteTestRun is the resolver for the deleteTestRun field.
func (r *mutationResolver) DeleteTestRun(ctx context.Context, id string) (bool, error) {
	return false, fmt.Errorf("DeleteTestRun not yet implemented")
}

// AssignTagsToTestRun is the resolver for the assignTagsToTestRun field.
func (r *mutationResolver) AssignTagsToTestRun(ctx context.Context, testRunID string, tagIds []string) (*model.TestRun, error) {
	return nil, fmt.Errorf("AssignTagsToTestRun not yet implemented")
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input model.CreateProjectInput) (*model.Project, error) {
	// Use domain service implementation
	return r.CreateProject_domain(ctx, input)
}

// UpdateProject is the resolver for the updateProject field.
func (r *mutationResolver) UpdateProject(ctx context.Context, id string, input model.UpdateProjectInput) (*model.Project, error) {
	// Use domain service implementation
	return r.UpdateProject_domain(ctx, id, input)
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, id string) (bool, error) {
	// Use domain service implementation
	return r.DeleteProject_domain(ctx, id)
}

// ActivateProject is the resolver for the activateProject field.
func (r *mutationResolver) ActivateProject(ctx context.Context, projectID string) (*model.Project, error) {
	return nil, fmt.Errorf("ActivateProject not yet implemented")
}

// DeactivateProject is the resolver for the deactivateProject field.
func (r *mutationResolver) DeactivateProject(ctx context.Context, projectID string) (*model.Project, error) {
	return nil, fmt.Errorf("DeactivateProject not yet implemented")
}

// CreateTag is the resolver for the createTag field.
func (r *mutationResolver) CreateTag(ctx context.Context, input model.CreateTagInput) (*model.Tag, error) {
	// Use domain service implementation
	return r.CreateTag_domain(ctx, input)
}

// UpdateTag is the resolver for the updateTag field.
func (r *mutationResolver) UpdateTag(ctx context.Context, id string, input model.UpdateTagInput) (*model.Tag, error) {
	return nil, fmt.Errorf("UpdateTag not yet implemented")
}

// DeleteTag is the resolver for the deleteTag field.
func (r *mutationResolver) DeleteTag(ctx context.Context, id string) (bool, error) {
	return false, fmt.Errorf("DeleteTag not yet implemented")
}

// MarkFlakyTestResolved is the resolver for the markFlakyTestResolved field.
func (r *mutationResolver) MarkFlakyTestResolved(ctx context.Context, id string) (*model.FlakyTest, error) {
	return nil, fmt.Errorf("MarkFlakyTestResolved not yet implemented")
}

// MarkSpecAsFlaky is the resolver for the markSpecAsFlaky field.
func (r *mutationResolver) MarkSpecAsFlaky(ctx context.Context, specRunID string) (*model.SpecRun, error) {
	return nil, fmt.Errorf("MarkSpecAsFlaky not yet implemented")
}

// UpdateUserPreferences is the resolver for the updateUserPreferences field.
func (r *mutationResolver) UpdateUserPreferences(ctx context.Context, input model.UpdateUserPreferencesInput) (*model.UserPreferences, error) {
	// Get current user
	user, err := getCurrentUser(ctx)
	if err != nil {
		return nil, err
	}

	// Get existing preferences or create new
	var prefs database.UserPreferences
	err = r.db.Where("user_id = ?", user.UserID).First(&prefs).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			// Create new preferences
			prefs = database.UserPreferences{
				UserID: user.UserID,
			}
		} else {
			return nil, fmt.Errorf("failed to get user preferences: %w", err)
		}
	}

	// Update fields if provided
	if input.Theme != nil {
		prefs.Theme = *input.Theme
	}
	if input.Timezone != nil {
		prefs.Timezone = *input.Timezone
	}
	if input.Language != nil {
		prefs.Language = *input.Language
	}
	if input.Favorites != nil {
		favoritesJSON, err := json.Marshal(input.Favorites)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal favorites: %w", err)
		}
		prefs.Favorites = favoritesJSON
	}
	if input.Preferences != nil {
		prefsJSON, err := json.Marshal(input.Preferences)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal preferences: %w", err)
		}
		prefs.Preferences = prefsJSON
	}

	// Save to database
	if err := r.db.Save(&prefs).Error; err != nil {
		return nil, fmt.Errorf("failed to save user preferences: %w", err)
	}

	// Convert favorites JSON to string array
	var favorites []string
	if prefs.Favorites != nil {
		if err := json.Unmarshal(prefs.Favorites, &favorites); err != nil {
			r.logger.WithError(err).Error("Failed to unmarshal favorites")
			favorites = []string{}
		}
	}

	// Convert preferences JSON to map
	var preferencesMap map[string]any
	if prefs.Preferences != nil {
		if err := json.Unmarshal(prefs.Preferences, &preferencesMap); err != nil {
			r.logger.WithError(err).Error("Failed to unmarshal preferences")
			preferencesMap = make(map[string]any)
		}
	} else {
		preferencesMap = make(map[string]any)
	}

	// Return updated preferences
	return &model.UserPreferences{
		ID:          fmt.Sprintf("%d", prefs.ID),
		UserID:      prefs.UserID,
		Theme:       &prefs.Theme,
		Timezone:    &prefs.Timezone,
		Language:    &prefs.Language,
		Favorites:   favorites,
		Preferences: preferencesMap,
		CreatedAt:   prefs.CreatedAt,
		UpdatedAt:   prefs.UpdatedAt,
	}, nil
}

// ToggleProjectFavorite is the resolver for the toggleProjectFavorite field.
func (r *mutationResolver) ToggleProjectFavorite(ctx context.Context, projectID string) (*model.UserPreferences, error) {
	// Get current user
	user, err := getCurrentUser(ctx)
	if err != nil {
		return nil, err
	}

	// Get existing preferences or create new
	var prefs database.UserPreferences
	err = r.db.Where("user_id = ?", user.UserID).First(&prefs).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			// Create new preferences with this project as favorite
			prefs = database.UserPreferences{
				UserID:      user.UserID,
				Theme:       "light",
				Timezone:    "UTC",
				Language:    "en",
				Favorites:   json.RawMessage(fmt.Sprintf(`["%s"]`, projectID)),
				Preferences: json.RawMessage("{}"),
			}
			if err := r.db.Create(&prefs).Error; err != nil {
				return nil, fmt.Errorf("failed to create user preferences: %w", err)
			}
		} else {
			return nil, fmt.Errorf("failed to get user preferences: %w", err)
		}
	} else {
		// Parse existing favorites
		var favorites []string
		if prefs.Favorites != nil {
			if err := json.Unmarshal(prefs.Favorites, &favorites); err != nil {
				r.logger.WithError(err).Error("Failed to unmarshal favorites")
				favorites = []string{}
			}
		}

		// Toggle the favorite
		found := false
		newFavorites := make([]string, 0)
		for _, fav := range favorites {
			if fav == projectID {
				found = true
				// Remove from favorites
			} else {
				newFavorites = append(newFavorites, fav)
			}
		}

		if !found {
			// Add to favorites
			newFavorites = append(newFavorites, projectID)
		}

		// Update favorites
		favoritesJSON, err := json.Marshal(newFavorites)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal favorites: %w", err)
		}
		prefs.Favorites = favoritesJSON

		// Save to database
		if err := r.db.Save(&prefs).Error; err != nil {
			return nil, fmt.Errorf("failed to save user preferences: %w", err)
		}

		// Update favorites for return
		favorites = newFavorites
	}

	// Convert favorites JSON to string array for return
	var returnFavorites []string
	if prefs.Favorites != nil {
		if err := json.Unmarshal(prefs.Favorites, &returnFavorites); err != nil {
			r.logger.WithError(err).Error("Failed to unmarshal favorites for return")
			returnFavorites = []string{}
		}
	}

	// Convert preferences JSON to map
	var preferencesMap map[string]any
	if prefs.Preferences != nil {
		if err := json.Unmarshal(prefs.Preferences, &preferencesMap); err != nil {
			r.logger.WithError(err).Error("Failed to unmarshal preferences")
			preferencesMap = make(map[string]any)
		}
	} else {
		preferencesMap = make(map[string]any)
	}

	// Return updated preferences
	return &model.UserPreferences{
		ID:          fmt.Sprintf("%d", prefs.ID),
		UserID:      prefs.UserID,
		Theme:       &prefs.Theme,
		Timezone:    &prefs.Timezone,
		Language:    &prefs.Language,
		Favorites:   returnFavorites,
		Preferences: preferencesMap,
		CreatedAt:   prefs.CreatedAt,
		UpdatedAt:   prefs.UpdatedAt,
	}, nil
}

// CreateJiraConnection is the resolver for the createJiraConnection field.
func (r *mutationResolver) CreateJiraConnection(ctx context.Context, input model.CreateJiraConnectionInput) (*model.JiraConnection, error) {
	// Check if user can manage the project
	user, err := getCurrentUser(ctx)
	if err != nil || user == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	project, err := r.projectService.GetProject(ctx, projectsDomain.ProjectID(input.ProjectID))
	if err != nil {
		return nil, fmt.Errorf("project not found")
	}

	// Check if user has manager permissions for this project
	permissions, err := r.projectService.GetUserPermissions(ctx, project.ProjectID(), user.UserID)
	if err != nil || len(permissions) == 0 {
		return nil, fmt.Errorf("forbidden")
	}

	connection, err := r.jiraConnectionService.CreateConnection(
		ctx,
		input.ProjectID,
		input.Name,
		input.JiraURL,
		integrations.AuthenticationType(input.AuthenticationType),
		input.ProjectKey,
		input.Username,
		input.Credential,
	)
	if err != nil {
		return nil, err
	}

	return r.convertJiraConnectionToModel(connection), nil
}

// UpdateJiraConnection is the resolver for the updateJiraConnection field.
func (r *mutationResolver) UpdateJiraConnection(ctx context.Context, id string, input model.UpdateJiraConnectionInput) (*model.JiraConnection, error) {
	// Check if user can manage the connection
	user, err := getCurrentUser(ctx)
	if err != nil || user == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	connection, err := r.jiraConnectionService.GetConnection(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("connection not found")
	}

	project, err := r.projectService.GetProject(ctx, projectsDomain.ProjectID(connection.ProjectID()))
	if err != nil {
		return nil, fmt.Errorf("project not found")
	}

	// Check if user has manager permissions for this project
	permissions, err := r.projectService.GetUserPermissions(ctx, project.ProjectID(), user.UserID)
	if err != nil || len(permissions) == 0 {
		return nil, fmt.Errorf("forbidden")
	}

	updated, err := r.jiraConnectionService.UpdateConnection(
		ctx,
		id,
		input.Name,
		input.JiraURL,
		input.ProjectKey,
	)
	if err != nil {
		return nil, err
	}

	return r.convertJiraConnectionToModel(updated), nil
}

// UpdateJiraCredentials is the resolver for the updateJiraCredentials field.
func (r *mutationResolver) UpdateJiraCredentials(ctx context.Context, id string, input model.UpdateJiraCredentialsInput) (*model.JiraConnection, error) {
	// Check if user can manage the connection
	user, err := getCurrentUser(ctx)
	if err != nil || user == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	connection, err := r.jiraConnectionService.GetConnection(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("connection not found")
	}

	project, err := r.projectService.GetProject(ctx, projectsDomain.ProjectID(connection.ProjectID()))
	if err != nil {
		return nil, fmt.Errorf("project not found")
	}

	// Check if user has manager permissions for this project
	permissions, err := r.projectService.GetUserPermissions(ctx, project.ProjectID(), user.UserID)
	if err != nil || len(permissions) == 0 {
		return nil, fmt.Errorf("forbidden")
	}

	updated, err := r.jiraConnectionService.UpdateCredentials(
		ctx,
		id,
		integrations.AuthenticationType(input.AuthenticationType),
		input.Username,
		input.Credential,
	)
	if err != nil {
		return nil, err
	}

	return r.convertJiraConnectionToModel(updated), nil
}

// TestJiraConnection is the resolver for the testJiraConnection field.
func (r *mutationResolver) TestJiraConnection(ctx context.Context, id string) (bool, error) {
	// Check if user can manage the connection
	user, err := getCurrentUser(ctx)
	if err != nil || user == nil {
		r.logger.Errorf("TestJiraConnection: unauthorized user")
		return false, fmt.Errorf("unauthorized")
	}

	connection, err := r.jiraConnectionService.GetConnection(ctx, id)
	if err != nil {
		r.logger.Errorf("TestJiraConnection: connection not found: %v", err)
		return false, fmt.Errorf("connection not found")
	}

	project, err := r.projectService.GetProject(ctx, projectsDomain.ProjectID(connection.ProjectID()))
	if err != nil {
		r.logger.Errorf("TestJiraConnection: project not found: %v", err)
		return false, fmt.Errorf("project not found")
	}

	// Check if user has manager permissions for this project
	permissions, err := r.projectService.GetUserPermissions(ctx, project.ProjectID(), user.UserID)
	if err != nil || len(permissions) == 0 {
		r.logger.Errorf("TestJiraConnection: forbidden for user %s on project %s", user.UserID, project.ProjectID())
		return false, fmt.Errorf("forbidden")
	}

	r.logger.Infof("Testing JIRA connection %s for project %s", id, project.ProjectID())
	if err := r.jiraConnectionService.TestConnection(ctx, id); err != nil {
		r.logger.Errorf("TestJiraConnection failed: %v", err)
		return false, nil // Return false but no error so GraphQL returns the boolean
	}

	r.logger.Infof("TestJiraConnection successful for connection %s", id)
	return true, nil
}

// DeleteJiraConnection is the resolver for the deleteJiraConnection field.
func (r *mutationResolver) DeleteJiraConnection(ctx context.Context, id string) (bool, error) {
	// Check if user can manage the connection
	user, err := getCurrentUser(ctx)
	if err != nil || user == nil {
		return false, fmt.Errorf("unauthorized")
	}

	connection, err := r.jiraConnectionService.GetConnection(ctx, id)
	if err != nil {
		return false, fmt.Errorf("connection not found")
	}

	project, err := r.projectService.GetProject(ctx, projectsDomain.ProjectID(connection.ProjectID()))
	if err != nil {
		return false, fmt.Errorf("project not found")
	}

	// Check if user has manager permissions for this project
	permissions, err := r.projectService.GetUserPermissions(ctx, project.ProjectID(), user.UserID)
	if err != nil || len(permissions) == 0 {
		return false, fmt.Errorf("forbidden")
	}

	if err := r.jiraConnectionService.DeleteConnection(ctx, id); err != nil {
		return false, err
	}

	return true, nil
}

// CanManage is the resolver for the canManage field.
func (r *projectResolver) CanManage(ctx context.Context, obj *model.Project) (bool, error) {
	// Get current user from context
	user, err := getCurrentUser(ctx)
	if err != nil {
		return false, nil // Not authenticated, can't manage
	}

	// Admin can manage all projects
	if user.Role == authDomain.RoleAdmin {
		return true, nil
	}

	// Get role group names from context
	roleGroups := getRoleGroupNamesFromContext(ctx)

	// Check if user has team + manager group combination
	if obj.Team != nil && *obj.Team != "" {
		hasTeamGroup := false
		hasManagerGroup := false

		for _, group := range user.Groups {
			groupName := strings.TrimPrefix(group.GroupName, "/")
			if groupName == *obj.Team {
				hasTeamGroup = true
			}
			if groupName == roleGroups.ManagerGroup {
				hasManagerGroup = true
			}
		}

		// If user is in both team and manager groups, they can manage
		if hasTeamGroup && hasManagerGroup {
			return true, nil
		}
	}

	// Check scopes for management permissions
	requiredScopes := []string{
		fmt.Sprintf("project:write:%s", obj.ProjectID),
		fmt.Sprintf("project:delete:%s", obj.ProjectID),
		fmt.Sprintf("project:*:%s", obj.ProjectID),
	}

	// If project has a team, also check team-based scopes
	if obj.Team != nil && *obj.Team != "" {
		requiredScopes = append(requiredScopes,
			fmt.Sprintf("project:write:%s:*", *obj.Team),
			fmt.Sprintf("project:*:%s:*", *obj.Team),
		)
	}

	// Check if user has any of the required scopes
	userScopes := getUserScopesFromContext(ctx)
	for _, scope := range userScopes {
		for _, required := range requiredScopes {
			if matchScope(scope, required) {
				return true, nil
			}
		}
	}

	// Check explicit project permissions in database
	// TODO: Migrate to domain permission model
	type ProjectPermission struct {
		ID         uint
		ProjectID  string
		UserID     string
		Permission string
		ExpiresAt  *time.Time
	}
	var perm ProjectPermission
	now := time.Now()
	err = r.db.Where("project_id = ? AND user_id = ? AND permission IN ? AND (expires_at IS NULL OR expires_at > ?)",
		obj.ProjectID, user.UserID, []string{"write", "delete", "admin"}, now).First(&perm).Error

	return err == nil, nil
}

// Stats is the resolver for the stats field.
func (r *projectResolver) Stats(ctx context.Context, obj *model.Project) (*model.ProjectStats, error) {
	// TODO: Implement project stats in domain service
	return nil, nil
}

// CurrentUser is the resolver for the currentUser field.
func (r *queryResolver) CurrentUser(ctx context.Context) (*model.User, error) {
	user, ok := ctx.Value("user").(*authDomain.User)
	if !ok {
		return nil, fmt.Errorf("user not authenticated")
	}

	// Extract group names from Groups
	groups := make([]string, len(user.Groups))
	for i, g := range user.Groups {
		groups[i] = g.GroupName
	}

	return &model.User{
		ID:          user.UserID,
		UserID:      user.UserID,
		Email:       user.Email,
		Name:        user.Name,
		FirstName:   &user.FirstName,
		LastName:    &user.LastName,
		Role:        string(user.Role),
		ProfileURL:  convertStringPtr(user.ProfileURL),
		Groups:      groups,
		CreatedAt:   user.CreatedAt,
		LastLoginAt: user.LastLoginAt,
	}, nil
}

// UserPreferences is the resolver for the userPreferences field.
func (r *queryResolver) UserPreferences(ctx context.Context) (*model.UserPreferences, error) {
	// Get current user
	user, err := getCurrentUser(ctx)
	if err != nil {
		return nil, err
	}

	// Get or create user preferences
	var prefs database.UserPreferences
	err = r.db.Where("user_id = ?", user.UserID).First(&prefs).Error
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			// Create default preferences
			prefs = database.UserPreferences{
				UserID:      user.UserID,
				Theme:       "light",
				Timezone:    "UTC",
				Language:    "en",
				Favorites:   json.RawMessage("[]"),
				Preferences: json.RawMessage("{}"),
			}
			if err := r.db.Create(&prefs).Error; err != nil {
				return nil, fmt.Errorf("failed to create user preferences: %w", err)
			}
		} else {
			return nil, fmt.Errorf("failed to get user preferences: %w", err)
		}
	}

	// Convert favorites JSON to string array
	var favorites []string
	if prefs.Favorites != nil {
		if err := json.Unmarshal(prefs.Favorites, &favorites); err != nil {
			r.logger.WithError(err).Error("Failed to unmarshal favorites")
			favorites = []string{}
		}
	}

	// Convert preferences JSON to map
	var preferencesMap map[string]any
	if prefs.Preferences != nil {
		if err := json.Unmarshal(prefs.Preferences, &preferencesMap); err != nil {
			r.logger.WithError(err).Error("Failed to unmarshal preferences")
			preferencesMap = make(map[string]any)
		}
	} else {
		preferencesMap = make(map[string]any)
	}

	// Convert to GraphQL model
	return &model.UserPreferences{
		ID:          fmt.Sprintf("%d", prefs.ID),
		UserID:      prefs.UserID,
		Theme:       &prefs.Theme,
		Timezone:    &prefs.Timezone,
		Language:    &prefs.Language,
		Favorites:   favorites,
		Preferences: preferencesMap,
		CreatedAt:   prefs.CreatedAt,
		UpdatedAt:   prefs.UpdatedAt,
	}, nil
}

// SystemConfig is the resolver for the systemConfig field.
func (r *queryResolver) SystemConfig(ctx context.Context) (*model.SystemConfig, error) {
	// Get role group names from context
	roleGroups := getRoleGroupNamesFromContext(ctx)

	return &model.SystemConfig{
		RoleGroups: &model.RoleGroupConfig{
			AdminGroup:   roleGroups.AdminGroup,
			ManagerGroup: roleGroups.ManagerGroup,
			UserGroup:    roleGroups.UserGroup,
		},
	}, nil
}

// DashboardSummary is the resolver for the dashboardSummary field.
func (r *queryResolver) DashboardSummary(ctx context.Context) (*model.DashboardSummary, error) {
	// Use domain service implementation
	return r.DashboardSummary_domain(ctx)
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (*model.HealthStatus, error) {
	version := "1.0.0" // TODO: Get from build info
	return &model.HealthStatus{
		Status:    "healthy",
		Service:   "fern-platform",
		Timestamp: time.Now(),
		Version:   &version,
	}, nil
}

// TreemapData is the resolver for the treemapData field.
func (r *queryResolver) TreemapData(ctx context.Context, projectID *string, days *int) (*model.TreemapData, error) {
	// Use domain service implementation
	return r.TreemapData_domain(ctx, projectID, days)
}

// TestRun is the resolver for the testRun field.
func (r *queryResolver) TestRun(ctx context.Context, id string) (*model.TestRun, error) {
	// Use domain service implementation
	return r.GetTestRun_domain(ctx, id)
}

// TestRunByRunID is the resolver for the testRunByRunId field.
func (r *queryResolver) TestRunByRunID(ctx context.Context, runID string) (*model.TestRun, error) {
	// Use domain service implementation
	testRun, err := r.testingService.GetTestRunByRunID(ctx, runID)
	if err != nil {
		return nil, fmt.Errorf("failed to get test run: %w", err)
	}

	graphqlTestRun := r.convertTestRunToGraphQL(testRun)

	return graphqlTestRun, nil
}

// TestRuns is the resolver for the testRuns field.
func (r *queryResolver) TestRuns(ctx context.Context, filter *model.TestRunFilter, first *int, after *string, orderBy *string, orderDirection *model.OrderDirection) (*model.TestRunConnection, error) {
	// Use domain service implementation
	return r.TestRuns_domain(ctx, filter, first, after, orderBy, orderDirection)
}

// TestRunStats is the resolver for the testRunStats field.
func (r *queryResolver) TestRunStats(ctx context.Context, projectID *string, days *int) (*model.TestRunStats, error) {
	// TODO: Implement test run stats using domain service
	return &model.TestRunStats{
		TotalRuns:       0,
		StatusCounts:    []*model.StatusCount{},
		AverageDuration: 0,
		SuccessRate:     0.0,
	}, nil
}

// RecentTestRuns is the resolver for the recentTestRuns field.
func (r *queryResolver) RecentTestRuns(ctx context.Context, projectID *string, limit *int) ([]*model.TestRun, error) {
	// Use domain service implementation
	return r.RecentTestRuns_domain(ctx, projectID, limit)
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, id string) (*model.Project, error) {
	// Use domain service implementation
	return r.Project_domain(ctx, id)
}

// ProjectByProjectID is the resolver for the projectByProjectId field.
func (r *queryResolver) ProjectByProjectID(ctx context.Context, projectID string) (*model.Project, error) {
	// Use domain service implementation
	return r.ProjectByProjectID_domain(ctx, projectID)
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context, filter *model.ProjectFilter, first *int, after *string) (*model.ProjectConnection, error) {
	// Use domain service implementation
	return r.Projects_domain(ctx, filter, first, after)
}

// Tag is the resolver for the tag field.
func (r *queryResolver) Tag(ctx context.Context, id string) (*model.Tag, error) {
	return nil, fmt.Errorf("Tag not yet implemented")
}

// TagByName is the resolver for the tagByName field.
func (r *queryResolver) TagByName(ctx context.Context, name string) (*model.Tag, error) {
	return nil, fmt.Errorf("TagByName not yet implemented")
}

// Tags is the resolver for the tags field.
func (r *queryResolver) Tags(ctx context.Context, filter *model.TagFilter, first *int, after *string) (*model.TagConnection, error) {
	// Use domain service implementation
	return r.Tags_domain(ctx, filter, first, after)
}

// TagUsageStats is the resolver for the tagUsageStats field.
func (r *queryResolver) TagUsageStats(ctx context.Context) ([]*model.TagUsage, error) {
	return nil, fmt.Errorf("TagUsageStats not yet implemented")
}

// PopularTags is the resolver for the popularTags field.
func (r *queryResolver) PopularTags(ctx context.Context, limit *int) ([]*model.TagUsage, error) {
	return nil, fmt.Errorf("PopularTags not yet implemented")
}

// FlakyTest is the resolver for the flakyTest field.
func (r *queryResolver) FlakyTest(ctx context.Context, id string) (*model.FlakyTest, error) {
	return nil, fmt.Errorf("FlakyTest not yet implemented")
}

// FlakyTests is the resolver for the flakyTests field.
func (r *queryResolver) FlakyTests(ctx context.Context, filter *model.FlakyTestFilter, first *int, after *string, orderBy *string, orderDirection *model.OrderDirection) (*model.FlakyTestConnection, error) {
	return nil, fmt.Errorf("FlakyTests not yet implemented")
}

// FlakyTestStats is the resolver for the flakyTestStats field.
func (r *queryResolver) FlakyTestStats(ctx context.Context, projectID *string) (*model.FlakyTestStats, error) {
	return nil, fmt.Errorf("FlakyTestStats not yet implemented")
}

// RecentlyAddedFlakyTests is the resolver for the recentlyAddedFlakyTests field.
func (r *queryResolver) RecentlyAddedFlakyTests(ctx context.Context, projectID *string, days *int, limit *int) ([]*model.FlakyTest, error) {
	return nil, fmt.Errorf("RecentlyAddedFlakyTests not yet implemented")
}

// JiraConnection is the resolver for the jiraConnection field.
func (r *queryResolver) JiraConnection(ctx context.Context, id string) (*model.JiraConnection, error) {
	conn, err := r.jiraConnectionService.GetConnection(ctx, id)
	if err != nil {
		return nil, err
	}

	return r.convertJiraConnectionToModel(conn), nil
}

// JiraConnections is the resolver for the jiraConnections field.
func (r *queryResolver) JiraConnections(ctx context.Context, projectID string) ([]*model.JiraConnection, error) {
	// Check if user can view the project
	user, err := getCurrentUser(ctx)
	if err != nil || user == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	connections, err := r.jiraConnectionService.GetProjectConnections(ctx, projectID)
	if err != nil {
		return nil, err
	}

	models := make([]*model.JiraConnection, len(connections))
	for i, conn := range connections {
		models[i] = r.convertJiraConnectionToModel(conn)
	}

	return models, nil
}

// TestRunCreated is the resolver for the testRunCreated field.
func (r *subscriptionResolver) TestRunCreated(ctx context.Context, projectID *string) (<-chan *model.TestRun, error) {
	ch := make(chan *model.TestRun)
	close(ch)
	return ch, nil
}

// TestRunUpdated is the resolver for the testRunUpdated field.
func (r *subscriptionResolver) TestRunUpdated(ctx context.Context, projectID *string) (<-chan *model.TestRun, error) {
	ch := make(chan *model.TestRun)
	close(ch)
	return ch, nil
}

// TestRunStatusChanged is the resolver for the testRunStatusChanged field.
func (r *subscriptionResolver) TestRunStatusChanged(ctx context.Context, projectID *string) (<-chan *model.TestRun, error) {
	ch := make(chan *model.TestRun)
	close(ch)
	return ch, nil
}

// FlakyTestDetected is the resolver for the flakyTestDetected field.
func (r *subscriptionResolver) FlakyTestDetected(ctx context.Context, projectID *string) (<-chan *model.FlakyTest, error) {
	ch := make(chan *model.FlakyTest)
	close(ch)
	return ch, nil
}

// SpecRuns is the resolver for the specRuns field.
func (r *suiteRunResolver) SpecRuns(ctx context.Context, obj *model.SuiteRun) ([]*model.SpecRun, error) {
	r.logger.WithField("suite_run_id", obj.ID).Debug("Loading spec runs for suite run")

	// Get data loader from context
	loaders := getLoaders(ctx)
	if loaders == nil {
		r.logger.Error("Data loaders not found in context")
		return nil, fmt.Errorf("data loaders not found in context")
	}

	// Load spec runs for this suite run - bypass DataLoader for now
	var specRuns []*database.SpecRun
	intID, err := strconv.Atoi(obj.ID)
	if err != nil {
		r.logger.WithError(err).WithField("suite_run_id", obj.ID).Error("Failed to parse suite run ID")
		return nil, fmt.Errorf("invalid suite run ID: %w", err)
	}

	if err := r.db.Where("suite_run_id = ?", intID).
		Preload("Tags").
		Find(&specRuns).Error; err != nil {
		r.logger.WithError(err).WithField("suite_run_id", obj.ID).Error("Failed to load spec runs directly")
		return nil, fmt.Errorf("failed to load spec runs: %w", err)
	}

	r.logger.WithFields(map[string]interface{}{
		"suite_run_id": obj.ID,
		"spec_count":   len(specRuns),
	}).Debug("Loaded spec runs")

	// Convert to GraphQL models
	result := make([]*model.SpecRun, len(specRuns))
	for i, sp := range specRuns {
		// Check for zero time values which might be interpreted as null
		startTime := sp.StartTime
		if startTime.IsZero() {
			r.logger.WithFields(map[string]interface{}{
				"spec_run_id": sp.ID,
				"spec_name":   sp.SpecName,
			}).Warn("SpecRun has zero StartTime, using current time")
			startTime = time.Now() // Use current time as fallback
		}

		// Convert tags
		tags := make([]*model.Tag, len(sp.Tags))
		for j, tag := range sp.Tags {
			tags[j] = &model.Tag{
				ID:       fmt.Sprintf("%d", tag.ID),
				Name:     tag.Name,
				Category: convertStringPtr(tag.Category),
				Value:    convertStringPtr(tag.Value),
			}
		}

		result[i] = &model.SpecRun{
			ID:           fmt.Sprintf("%d", sp.ID),
			SuiteRunID:   fmt.Sprintf("%d", sp.SuiteRunID),
			SpecName:     sp.SpecName,
			Status:       sp.Status,
			StartTime:    startTime,
			EndTime:      sp.EndTime,
			Duration:     int(sp.Duration),
			ErrorMessage: convertStringPtr(sp.ErrorMessage),
			StackTrace:   convertStringPtr(sp.StackTrace),
			RetryCount:   sp.RetryCount,
			IsFlaky:      sp.IsFlaky,
			Tags:         tags,
			CreatedAt:    sp.CreatedAt,
			UpdatedAt:    sp.UpdatedAt,
		}
	}

	return result, nil
}

// SuiteRuns is the resolver for the suiteRuns field.
func (r *testRunResolver) SuiteRuns(ctx context.Context, obj *model.TestRun) ([]*model.SuiteRun, error) {
	r.logger.WithField("test_run_id", obj.ID).Debug("Loading suite runs for test run")

	// Get data loader from context
	loaders := getLoaders(ctx)
	if loaders == nil {
		r.logger.Error("Data loaders not found in context")
		return nil, fmt.Errorf("data loaders not found in context")
	}

	// Load suite runs for this test run
	r.logger.WithField("test_run_id", obj.ID).Debug("About to load suite runs")

	// For now, bypass DataLoader to test if that's the issue
	var suiteRuns []*database.SuiteRun
	intID, err := strconv.Atoi(obj.ID)
	if err != nil {
		r.logger.WithError(err).WithField("test_run_id", obj.ID).Error("Failed to parse test run ID")
		return nil, fmt.Errorf("invalid test run ID: %w", err)
	}

	if err := r.db.Where("test_run_id = ?", intID).
		Preload("Tags").
		Preload("SpecRuns").
		Preload("SpecRuns.Tags").
		Find(&suiteRuns).Error; err != nil {
		r.logger.WithError(err).WithField("test_run_id", obj.ID).Error("Failed to load suite runs directly")
		return nil, fmt.Errorf("failed to load suite runs: %w", err)
	}

	r.logger.WithFields(map[string]interface{}{
		"test_run_id": obj.ID,
		"suite_count": len(suiteRuns),
	}).Debug("Loaded suite runs directly without DataLoader")

	// Convert to GraphQL models
	result := make([]*model.SuiteRun, len(suiteRuns))
	for i, sr := range suiteRuns {
		// Convert tags
		tags := make([]*model.Tag, len(sr.Tags))
		for j, tag := range sr.Tags {
			tags[j] = &model.Tag{
				ID:       fmt.Sprintf("%d", tag.ID),
				Name:     tag.Name,
				Category: convertStringPtr(tag.Category),
				Value:    convertStringPtr(tag.Value),
			}
		}

		result[i] = &model.SuiteRun{
			ID:           fmt.Sprintf("%d", sr.ID),
			TestRunID:    fmt.Sprintf("%d", sr.TestRunID),
			SuiteName:    sr.SuiteName,
			Status:       sr.Status,
			StartTime:    sr.StartTime,
			EndTime:      sr.EndTime,
			TotalSpecs:   sr.TotalSpecs,
			PassedSpecs:  sr.PassedSpecs,
			FailedSpecs:  sr.FailedSpecs,
			SkippedSpecs: sr.SkippedSpecs,
			Duration:     int(sr.Duration),
			Tags:         tags,
			CreatedAt:    sr.CreatedAt,
			UpdatedAt:    sr.UpdatedAt,
		}
	}

	return result, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Project returns generated.ProjectResolver implementation.
func (r *Resolver) Project() generated.ProjectResolver { return &projectResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// SuiteRun returns generated.SuiteRunResolver implementation.
func (r *Resolver) SuiteRun() generated.SuiteRunResolver { return &suiteRunResolver{r} }

// TestRun returns generated.TestRunResolver implementation.
func (r *Resolver) TestRun() generated.TestRunResolver { return &testRunResolver{r} }

type mutationResolver struct{ *Resolver }
type projectResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type suiteRunResolver struct{ *Resolver }
type testRunResolver struct{ *Resolver }
